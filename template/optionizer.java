import java.io.PrintStream;
import java.lang.invoke.MethodHandles.Lookup;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Locale;
import java.util.stream.Collectors;

public class optionizer {
  // <insert content here>


  // specific code below

  private static String name(Option<?> option) {
    return option.names().iterator().next().replace('-', '_');
  }

  private static Optional<String> methodRef(ConverterResolver.ConverterMirror mirror) {
    if (mirror.implClass.equals(ConverterResolver.class.getName())) {
      return switch(mirror.implMethodName()) {
        case "basic" -> Optional.empty();
        case "enumerated" -> Optional.of(mirror.captures().get(0) + "::valueOf");
        case "reflected", "unwrap" -> methodRef((ConverterResolver.ConverterMirror) mirror.captures().get(0));
        default -> throw new AssertionError("unknown mirror inside ConverterResolver");
      };
    }
    return Optional.of(mirror.implClass() + "::" + mirror.implMethodName);
  }

  private static Converter<?,?> converter(Option<?> option) {
    return switch (option.type()) {
      case BRANCH -> ((Option.Branch<?>) option).converter;
      case FLAG -> ((Option.Flag) option).converter;
      case SINGLE -> ((Option.Single<?>) option).converter;
      case REPEATABLE -> ((Option.Repeatable<?>) option).converter;
      case REQUIRED -> ((Option.Required<?>) option).converter;
      case VARARGS -> ((Option.Required<?>) option).converter;
    };
  }

  private static String appendConvert(Optional<ConverterResolver.ConverterMirror> mirror, String expr) {
    return mirror.flatMap(m -> methodRef(m)).map(ref -> expr + ".convert(%s)".formatted(ref)).orElse(expr);
  }

  private static void generateClassFile(Schema<?> schema, Lookup lookup, ConverterResolver resolver, PrintStream out) {
    System.out.println("// generated by the optionizer");
    var options = schema.options;
    out.print("""
        import CommandLineInterface.Option;
        
        class Main {
          public static void main(String[] args) {
        """);
    for(var option: options) {
      var names = option.names().stream().map(n -> "\"" + n + "\"").collect(Collectors.joining(", ", "(", ")"));
      var expr = "Option." + option.type().name().toLowerCase(Locale.ROOT) + names;
      if (!option.help().isEmpty()) {
        expr = expr + ".help(\"%s\")".formatted(option.help());
      }
      expr = appendConvert(ConverterResolver.ConverterMirror.of(lookup, converter(option)), expr);
      var text = "var " + name(option) + " = " + expr + ';';
      out.print(text.indent(4));
    }

    out.printf("var splitter = Splitter.of(%s);".indent(4),
        options.stream().map(optionizer::name).collect(Collectors.joining(", ")));

    out.print("""
          }
        }
        """);
  }

  // test with: java ./generated/optionizer.java classes/test/test/AssortedTests\$7Options.class
  public static void main(String... args) throws Exception {
    record ArgParameters(
        @Help("an optional output file (not implemented yet !)")
        Optional<Path> output,
        @Help("a class file (a .class file)")
        String fileName
    ) {}

    var lookup = MethodHandles.lookup();
    var splitter = Splitter.of(lookup, ArgParameters.class);
    ArgParameters argParameters;
    try {
      argParameters = splitter.split(args);
    } catch(SplittingException e) {
      System.err.println("error " + e.getMessage());
      System.err.println("help : ");
      System.err.println(Manual.help(splitter.schema()));
      System.exit(1);
      return;
    }

    var path = Path.of(argParameters.fileName);
    var bytecode = Files.readAllBytes(path);
    var clazz = new ClassLoader() {
      Class<?> define(byte[] bytecode) {
        return super.defineClass(null, bytecode, 0, bytecode.length);
      }
    }.define(bytecode);
    if (!clazz.isRecord()) {
      throw new IllegalStateException("class " + argParameters.fileName + "is not a record");
    }

    var resolver = ConverterResolver.defaultResolver();
    var schema = Splitter.of(lookup, clazz.asSubclass(Record.class), resolver).schema();

    generateClassFile(schema, lookup, resolver, System.out);
  }
}